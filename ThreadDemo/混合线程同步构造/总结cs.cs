using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ThreadDemo.混合线程同步构造
{
    class 总结cs
    {
        /*
         代码尽量不要阻塞任何线程,执行异步计算或I/O操作时,将数据从一个线程交给另一个线程时,
         应避免多个线程同时访问数据,如果不能完全作到这一点时,请尽量使用Volatile和Interlocked方法。因为他们速度很快。
         而且绝不阻塞线程，遗憾的是这些方法只能操作简单类型。
         主要在以下两种情况下阻塞线程
         1.线程模型很简单。阻塞线程回牺牲一些资源和性能，但可以顺序地写应用程序代码，无需使用回调方法，
         不过，C#异步方法功能限制提供了一个不阻塞线程的简化变成模型。
         2.线程有专门的用途
         有的线程是特定任务专用的，最好的例子就是应用程序主线程，如果应用程序主线程没有阻塞，它最终回返回，造成整个进程终止
         其他例子还有应用程序的GUI线程，Windows要求一个窗口或空间总是由创建它的线程操作，因此我们有时写代码阻塞一个GUI线程
         知道其他某个操作完成然后GUI线程根据需要对窗口和控件进行更新。当然阻塞GUI线程回造成应用程序挂起，使用户体验差。
         要避免阻塞线程，就不要刻意的为线程打上标签，不要创建一个拼写检查线程，一个语法检查线程，一个处理特定客户端请求
         的线程等，为线程打上标签，其实是在告诫自己该线程不能做其他任何事情，由于线程是如此昂贵，所以不能把它们专门用于某个目的
         相反，应通过线程池将线程出租短暂时间，所以正确方式是一个线程池线程开始拼写检查，再改为语法检查，再代表一个客户端请求
         执行工作。以此类推。
         如果一定要阻塞线程，为了同步再不同AppDomain或进程中运行的线程。请使用内核对象构造。要在一系列操作这种原子性的操作
         状态，请使用带有私有字段的Monitor类，另外可以使用Reader-writer锁代替Monitor，Reader-writer锁通常逼Monitor慢，但它们
         允许多个线程并发执行，提升了总体性能，并将阻塞线程的机率降到最低。避免使用递归（尤其是递归的reader-writer锁）因为他们
         损害性能。但Monitor是递归的，性能也不错，另外不要再finally中释放锁，因为进入和离开异处理块会招致性能损失，如果再更改状态之前
         抛出异常，状态会损坏，操作这个状态的其他线程会出现不可预料的行为，并可能引入安全隐患。

        如果写代码来占有锁，注意时间不要太长，否则会增大线程阻塞的概率。（后面会说如何利用集合防止长时间占有锁）

        可以使用Task，避免使用大量线程同步构造。每个任务都关联或多个延续任务，某个操作完成后，这些任务通过某个线程池线程继续执行。
        这比让一个线程阻塞并等待某个操作完成好得多。对于IO限制的工作。调用各种XxxAsync方法将造成你的代码在IO操作完成后继续，这其实类似任务的延续任务。
         
         */
    }
}
