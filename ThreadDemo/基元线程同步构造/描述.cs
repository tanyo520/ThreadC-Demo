using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ThreadDemo.基元线程同步构造
{
    class 描述
    {
        public void Demo() {
            /*
               基元 是指可以在代码中使用的最简单的构造，有两种基元构造，用户模式和内核模式
               应尽量使用基元用户模式，他的速度要显著于内核模式的构造，因为他们使用了特殊cpu指令来协助线程。这意味着再硬件中发生的（所以才会快）但这也意味着
               操作系统永远检测不到一个线程再基元用户模式的构造上阻塞了。由于再用户模式的基元构造上阻塞的线程池线程永远不认为已阻塞。所以线程池不会创建新的线程
               来替换这种临时的阻塞线程。这些cpu指令只阻塞相当短的时间。
               缺点：
               windows操作系统内核才能停止一个线程的运行。（防止他浪费cpu时间）。在用户模式中运行的线程可能被系统抢占。但线程会以最快的速度再次调度
               所以 想要取得资源但暂时取不到的线程会一直在用户模式中自旋。这可能浪费大量cpu时间。而这些cpu时间本可以用来执行其他更有用的工作。即便没有其他工作
               让他空闲。至少能省电。

            内核模式：
             由系统自身提供的。它们要求在应用程序的线程中调用由操作系统内核实现的函数。将用户模式切换到内核模式（或反之）会招致巨大的性能损失。这正是为何
             要避免使用内核模式的原因。他有个重要的优点：线程通过内核模式的构造获取其他线程拥有的资源时，windows会阻塞线程以避免它浪费cpu时间。当资源变的可用时
             他会恢复线程。允许它访问资源。

            对于再一个构造上等待的线程。如果拥有这个构造的线程一直不释放它，前者就可能一直阻塞。如果是用户模式的构造，线程就一直再cpu上运行。
            我们称为活锁。如果是再内核模式上构造，线程一直阻塞，称为死锁。两者都不好。两者之间死锁优于活锁，因为活锁浪费cpu时间。又浪费内存（
            线程栈等。）死锁只浪费内存。

            我们应该结合2者。这样确实存在。称为混合构造。
            CLR的许多线程同步构造实际只是win32线程同步构造。的一些面向对象的类包装器。毕竟，clr线程就是windows线程。这意味着要由windows条都线程
            和控制线程同步。windows线程同步构造自1992年便存在了。
             */
        }
    }
}
