using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ThreadDemo
{
    /// <summary>
    /// window如何执行IO操作
    /// </summary>
    class WindowsIO
    {
        public void Demo() {
            /*
             连接了几个硬件设备的计算机系统，每个硬件设备都有自己的电路板，每个电路板都集成了一个小型的，特殊用途的计算机，它知道如何控制自己的硬件设备
             例如：硬盘驱动器就有一个小的电路板，他知道如何转碟片，寻道，在碟片上读写数据以及和计算机内存交换数据。

            程序通过构造一个FileStream对象来打开磁盘文件，然后read方法从文件中读取数据，同时你的线程从托管代码转变为本机/用户模式代码
            Read内部调用win32 ReadFile函数。ReadFile分配一个小的数据结构，称为IO请求包（IRP）IRP结构初始化后包含的内容有：文件句柄
            文件中的偏移量(从这个位置开始读取字节)，一个byte[]数组的地址（数组用读取的字节来填充）要传输的字节数以及其他常规性内容

            同步
             .net 托管代码--》win32用户模式函数--IRP-》windows内核模式-根据IRP的设备句柄找到设备--》IRP队列（NTFS驱动程序）--》你的线程在这里阻塞 硬件执行IO 不涉及任何线程。
             ---》返回Windows内核---》win32用户模式---》.net托管程序。

            在同步期间如果是web服务器多个线程同时阻塞再硬件操作的时候。所有内核，win31,托管线程和资源不能释放，造成极大浪费。
            还有当处理完后线程会解锁，可能大量线程运行。会造成频繁的执行上下文切换。进一步损害性能。

         异步
         .net托管代码--》win32用户模式--IRP--》windows内核模式---根据IRP的设备句柄找到设备--》IRP队列（NTFS驱动程序）---》
         不阻塞-立即返回-到.net托管代码。
         --》设备处理完以后--》CLR线程池，线程可以从这里提取完成的IRPS。---》任务完成，要么返回结果，要么抛出异常。

            硬件处理IRP后回将完成的IRP放入CLR的线程池队列中，将来某个时候，一个线程池线程回提取完成的IRP并执行完成任务的代码。

        举例：如果传入一个客户端请求后服务器发出一个异步数据库请求，此时线程不会阻塞，他可返回线程池以处理传入的更多客户端请求
        所以限制用一个线程就能吹所有传入的客户端请求，数据库服务器响应之后，他的响应回进入线程池队列。线程池线程再某个时间处理它
        最后需要将数据发送回客户端。这种情况下，只用一个线程处理了客户端所有的请求和所有的数据库响应。服务器只需要极少的系统资源
        。同时运行速度也得到了保证。尤其是考虑到根本不会发生上下文切换

            如果工作项被送入线程池的速度逼一个线程的处理他们的速度还要快。线程池会创建额外的线程。线程池很快回为机器上每个cpu创建线程。

            例如再4核机器上。4个客户断请求/数据库响应（任意组合）可以再4个线程上同时运行。而且不会发生上下文切换。


             
             */
        }
    }
}
